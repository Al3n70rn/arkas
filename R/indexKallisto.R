#' index transcriptome/transcriptomes (w/MD5 digest to avoid duplicating work)
#' NOTE: This function will seek to disambiguate any duplicate-named sequences
#' FIXME: automatically annotate heretofore-unseen Ensembl/RepBase/ERCC FASTAs
#' 
#' @param fastaFiles      a character string or vector of FASTA transcriptomes
#' @param fastaPath       where to find the preceding FASTA files 
#' @param fastaTxDbLite   boolean: should we try to annotate new FASTAs? (yes)
#'
#' @import tools
#' @import TxDbLite
#' @import Rsamtools
#' 
#' @export
#'
indexKallisto <- function(fastaFiles, fastaPath, fastaTxDbLite=TRUE, ...) { 

  oldwd <- getwd()
  setwd(fastaPath)

  indexName <- .getIndexName(fastaFiles)
  indexPath <- .getIndexPath(indexName, fastaPath)

  ## prepare to return if cached
  res <- list(indexName=indexName, 
              fastaFiles=fastaFiles, 
              fastaPath=fastaPath)

  ## See if the index and its digest already exist; if so, whether they match.
  if (!file.exists(indexPath)) {

    ## Check the FASTA files for duplicate seqnames:
    dupes <- findDupes(fastaFiles)
    if (!is.null(dupes)) {
      duplicatedSeqnames <- unique(dupes$seqname)
      message("There are duplicated sequence names in your FASTA files:")
      for (seqname in duplicatedSeqnames) { 
        dupeFastas <- dupes[dupes$seqname == seqname, "fastaFile"]
        id <- "" 
        if (all(dupes[dupes$seqname == seqname, "allIdentical"])) { 
          id <- " (all of the nucleotide sequences are identical)"
        }
        message(seqname, id, ":")
        for (fasta in dupeFastas) {
          message("  appears in ", fasta)
        }
      }
      stop("You need to fix this, otherwise the output will choke Sleuth.")
    }

    ## No dupes, proceed...
    command <- paste(c("kallisto index -i", indexName, fastaFiles),collapse=" ")
    retval <- system(command=command)
    setwd(oldwd)
    if (retval == 0) {
      return(res)
    } else { 
      stop("Index generation failed.")
    }

    if (fastaTxDbLite) {
      for (fastaFile in fastaFiles) { 
        if (!.checkForAnnotation(fastaFile)) {
          createAnnotationPackage(fastaFile, 
                                  author="Autogenerated <dev@null.com>")
        }
      }
    }

  } else { 
    message("Index ", indexPath, " was found... delete it to regenerate it.")
  }
  return(res)

}

#' @import TxDbLite
.checkForAnnotation <- function(fastaFile) {
  type <- getAnnotationType(fastaFile)
  if (!is.null(type)) {
    txDbLiteName <- paste(type, getFastaStub(fastaFile), sep=".")
    if (!suppressWarnings(require(txDbLiteName, character.only=TRUE))) {
      return(FALSE) ## we know how to create the annotations, but haven't yet  
    }
  }
  return(TRUE)
}

#' @import TxDbLite
.getIndexName <- function(fastaFiles) {
  cleanNames <- function(x) unique(sort(getFastaStub(x)))
  return(paste0(paste(cleanNames(fastaFiles), collapse="_"), ".fa.kidx"))
}

.getIndexPath <- function(indexName, fastaPath) {
  return(paste0(path.expand(fastaPath), "/", indexName))
}
